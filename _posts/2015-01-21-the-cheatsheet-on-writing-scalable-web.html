---
layout: post
title: The cheatsheet on writing scalable web apps
date: '2015-01-21T10:55:00.002+02:00'
author: Hossam Hammady
tags: 
modified_time: '2015-01-21T10:55:39.271+02:00'
blogger_id: tag:blogger.com,1999:blog-1427064072400819258.post-6994381753481248510
blogger_orig_url: http://blog.hammady.net/2015/01/the-cheatsheet-on-writing-scalable-web.html
---

<ol>  <li class="li4"><span class="s1"></span>Scale horizontally (<a href="http://en.wikipedia.org/wiki/Scalability">scale out</a>): Separate system tiers on different environments: database, Solr, memcached, push, web/app servers. Separation helps in scaling up/down tiers individually.</li>  <li class="li4">Use the cloud (<a href="http://en.wikipedia.org/wiki/Platform_as_a_service">Platform as a Service</a>) right away that facilitates scaling out/up/down (<a href="https://cloud.google.com/appengine">Google AppEngine</a>, <a href="https://www.heroku.com">Heroku</a>, <a href="http://aws.amazon.com/elasticbeanstalk/">AWS Beanstalk</a>, …</li>  <li class="li4">Monitor usage on each tier to scale up/down in the correct time (e.g. <a href="http://newrelic.com">NewRelic</a>)</li>  <li class="li4">Use push instead of server polling (<a href="http://pusher.com">Pusher</a>)</li>  <li class="li4">Don’t use filesystems for storage, unless it is a distributed filesystem (<a href="http://aws.amazon.com/s3/">AWS S3</a>)</li>  <li class="li4">Don’t involve your app server in long requests/responses. Slow clients may block your server and cause longer request queues (depends on implementation).<span class="Apple-converted-space"> </span></li>  <ul class="ul1">    <li class="li4">If you want to receive an upload <a href="https://devcenter.heroku.com/articles/direct-to-s3-image-uploads-in-rails">get it through S3</a> with some work on the client side.<span class="Apple-converted-space"> </span></li>    <li class="li4">If you want to send a huge response, either stream it using a streaming capability of your app server, or generate it using a background job that stores it finally on S3 and sends the direct link when done through the app using push or through email.</li>  </ul>  <li class="li4">Defer long tasks to background jobs (<a href="https://github.com/resque/resque">Resque</a>, <a href="http://www.rabbitmq.com/tutorials/tutorial-two-python.html">RabbitMQ</a>, Ruby <a href="https://github.com/collectiveidea/delayed_job">delayed jobs</a>, …)</li>  <li class="li4">Don’t clutter your app server memory with language bindings, use <a href="https://thrift.apache.org">Apache Thrift</a> or <a href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers</a> to communicate between different environments</li>  <li class="li4">Use <a href="http://lucene.apache.org/solr/">Apache Solr</a> (Lucene over HTTP) to query large data even if you don’t have full text search, it can be used for scoping and faceting as well (think SQL WHERE and GROUP BY)</li>  <li class="li4">Autoscale your web/app servers depending on traffic. Monitoring shows you traffic metrics and <a href="http://hirefire.io">HireFire</a> will autoscale your heroku dynos</li>  <li class="li4">Use clients-side rendering (<a href="http://www.creativebloq.com/web-design/templating-engines-9134396">Javascript templates</a>) to get rid of the rendering time on the server</li>  <li class="li4">Use caching in different layers (<a href="http://memcached.org">memcached</a>) to be nice on your servers</li>  <li class="li4">Asset hosting, static assets (javascripts, stylesheets, html templates, images, …) have nothing to do with your app servers so host them somewhere else (<a href="http://aws.amazon.com/cloudfront/">CloudFront</a>/S3)</li></ol> 